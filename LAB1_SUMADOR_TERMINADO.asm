/*
* SUMADOR DE 4 BITS
*
* Creado: 3/02/2026 
* Autor : Omar Cabrera 
* Descripción: Hacer un sumador de 4 bits compuesto de dos contadores, los cuales pueden incrementar o decrementarse. Se muestra el resultado y si hay carry. 
*/
/******/
// Encabezado (Definición de Registros, Variables y Constantes)
.include "M328PDEF.inc"     // Include definitions specific to ATMega328P
.dseg
.org    SRAM_START
//variable_name:     .byte   1   // Memory alocation for variable_name:     .byte   (byte size)

.cseg
.org 0x0000
 /******/
// Configuración de la pila
LDI     R16, LOW(RAMEND)
OUT     SPL, R16
LDI     R16, HIGH(RAMEND)
OUT     SPH, R16
/******/
// Configuracion MCU
SETUP:
	// Configuración del prescaler a 1 MHz 
	LDI R17, (1 << CLKPCE)
	STS CLKPR, R17
	LDI R17, 0b0000_0100
	STS CLKPR, R17

//CONFIGURACIÓN DE ENTRADAS Y SALIDAS 

	//OUTPUTS DEL CONTADOR 1
	LDI R16, 0b0000_1111
	OUT DDRB, R16					// EL PUERTO B ALMACENA 4 SALIDAS PARA LAS 4 LEDS DEL CONTADOR 1 
	LDI R16, 0b0000_0000 
	OUT PORTB, R16					// TODOS LOS LEDS ESTÁN INICIALMENTE APAGADOS 
									// PB0,PB1,PB2,PB3 = LEDS DEL PRIMER CONTADOR
									
	//OUTPUTS E INPUTS CONTADOR 2 
	LDI R16, 0b0000_1111  
	OUT DDRC, R16					// EL PUERTO C ALMACENA 4 SALIDAS PARA LAS 4 LEDS DEL CONTADOR 2 Y LOS DOS BOTONES PARA CONTROLAR EL CONTADOR2
	LDI R16, 0b0011_0000
	OUT PORTC, R16					// TODOS LOS LEDS DEL PUERTO C ESTÁN INICIALMENTE APAGADOS Y SE ACTIVA PULL-UP PARA BOTONES DEL CONTADOR 2 
									// PC0,PC1,PC2,PC3 = LEDS DEL SEGUNDO CONTADOR 
									// PC4,PC5 = ENTRADAS PARA LOS BOTONES DEL CONTADOR 2
									// PC4 INCREMENTO
									// PC5 DECREMENTO
	
	// INPUTS (BOTONES CONTADOR 1 Y BOTÓN DE RESULTADO) OUTPUTS PARA EL RESULTADO DE LA SUMA Y EL LED CARRY
	LDI R16, 0b0001_1111
	OUT DDRD, R16
	LDI R16, 0b1110_0000			// SE ACTIVAN PULL-UPS PARA LOS BOTONES 
									// PD5 INCREMENTO DE CONTADOR 1 
									// PD6 DECREMENTO DE CONTADOR 1 
									// PD7 BOTÓN DE RESULTADO 			

	


	//INICIALIZAR VARIABLES
	CLR R18							// ALMACENA CONTADOR 1
	CLR R19							// ALMACENA CONTADOR 2
	CLR R22							// ALMACENA RESULTADO DE LA SUMA DE CONTADORES 
    
/******/
// Loop Infinito
MAIN_LOOP:

	// COMIENZA LÓGICA PARA DETECTAR QUE BOTÓN SE PRESIONÓ

	SBIS PIND, PD5					// REVISA EL PIND5 QUE CORRESPONDE AL BOTÓN DE INCREMENTO C1, CUANDO PRESIONE ESTARÁ EN 0 Y SE EJECUTARÁ EL CALL DE INCREMENTAR. 
	CALL INCREMENTAR_CONTADOR1		// SE LLAMA A LA FUNCIÓN DE INCREMENTAR C1 
	SBIS PIND, PD6					// REVISA EL PIND6 QUE CORRESPONDE AL BOTÓN DE DECREMENTO C1, SI ESTÁ EN 1 (NO PRESIONADO POR PULL-UP) ENTONCES SKIPEA EL LLAMADO Y SALTA A JUMP
	CALL DECREMENTAR_CONTADOR1		// SE LLAMA A LA FUNCIÓN DE DECREMENTO C1
	SBIS PINC, PC4					// REVISA EL PINC4 QUE CORRESPONDE AL BOTÓN DE INCREMENTO C2 
	CALL INCREMENTAR_CONTADOR2		// SE LLAMA A LA FUNCIÓN DE INCREMENTAR C2.
	SBIS PINC, PC5					// REVISA EL PINC5 QUE CORRESPONDE AL BOTÓN DE DECREMENTO C2
	CALL DECREMENTAR_CONTADOR2		// SE LLAMA A LA FUNCIÓN DE DECREMENTO C2 
	SBIS PIND, PD7					// REVISA EL PIND7 QUE CORRESPONDE AL BOTÓN DE RESULTADO
	CALL RESULTADO 
	RJMP MAIN_LOOP 

/******/
// NON-Interrupt subroutines

INCREMENTAR_CONTADOR1: 
	CALL DELAY 
	INC R18 
	CPI R18, 0b0001_0000			// COMPARA EL CONTADOR 1 CON 16, DE SER IGUALES SE LLAMA A LA FUNCIÓN OVERFLOW
	BREQ OVERFLOW_CONTADOR1
	OUT PORTB, R18 
	RET

OVERFLOW_CONTADOR1: 
	LDI R16, 0b0000_0000			// CARGAMOS A UN REGISTRO 0, PARA QUE HAYA OVERFLOW Y EL CONTADOR VUELVA A 0 DESPUÉS DE 15
	MOV R18, R16
	OUT PORTB, R18
	RET

DECREMENTAR_CONTADOR1:
	CALL DELAY 
	DEC R18 
	CPI R18, 0b1111_1111			// COMPARAR EL CONTADOR 1 CON 255, DE SER IGUALES SE LLAMA A LA FUNCIÓN UNDERFLOW 
	BREQ UNDERFLOW_CONTADOR1	
	OUT PORTB, R18
	RET

UNDERFLOW_CONTADOR1: 
	LDI R16, 0b0000_1111			// CARGAMOS A UN REGISTRO 15, PARA QUE HAYA UNDERFLOW EXPLÍCITO Y PASE DE 0 A 15
	MOV R18, R16
	OUT PORTB, R18 
	RET

INCREMENTAR_CONTADOR2: 
	CALL DELAY
	INC R19 
	CPI R19, 0b0001_0000			// COMPARAR EL CONTADOR 2 CON 16, DE SER IGUALES SE LLAMA A LA FUNCIÓN OVERFLOW
	BREQ OVERFLOW_CONTADOR2
	MOV R16, R19					// MOVER A OTRO REGISTRO EL VALOR DEL CONTADOR PARA NO ALTERAR EL CONTADOR CON LA MEDIDA PARA DEJAR PULL UP
	ORI R16, 0b0011_0000			// SE HACE OR ENTRE EL CONTADOR Y 0011_0000 PARA MANTENER PULL_UP
	OUT PORTC, R16					
	RET

OVERFLOW_CONTADOR2: 
	LDI R16, 0b0000_0000			// CARGAMOS A UN REGISTRO 0, PARA QUE NO HAYA OVERFLOW Y EL CONTADOR VUELVA A 0 DESPUÉS DE 15
	MOV R19, R16
	OUT PORTC, R19					//QUE EL OVERFLOW SAQUE EL VALOR DEL PORT Y ENSEÑE CUANDO VUELVE A 0
	RET

DECREMENTAR_CONTADOR2:
	CALL DELAY
	DEC R19
	CPI R19, 0b1111_1111			// COMPARA EL CONTADOR 2 CON 255, DE SER IGUALES SE LLAMA A LA FUNCIÓN UNDERFLOW
	BREQ UNDERFLOW_CONTADOR2 
	MOV R16, R19					// MOVER A OTRO REGISTRO EL VALOR DEL CONTADOR PARA NO ALTERAR EL CONTADOR CON LA MEDIDA PARA DEJAR PULL UP
	ORI R16, 0b0011_0000 
	OUT PORTC, R16
	RET

UNDERFLOW_CONTADOR2: 
	LDI R16, 0b0000_1111			// CARGAMOS A UN REGISTRO 15, PARA QUE HAYA UNDERFLOW EXPLÍCITO Y PASE DE 0 A 15
	MOV R19, R16
	OUT PORTC, R19 
	RET

RESULTADO: 
	CALL DELAY
	MOV R22, R18					// HAY QUE MOVER EL RESULTADO DE CUALQUIERA DE LOS DOS CONTADORES A OTRO REGISTRO, PARA NO AFECTAR NI UN CONTADOR AL HACER SUMA
	ADD R22, R19					// SE SUMAN LOS VALORES DE LOS CONTADORES, SIN AFECTAR EL NÚMERO QUE TIENEN Y SE ALMACENA EL RESULTADO EN R22. 
	MOV R16, R22					// COPIAR EN OTRO REGISTRO EL VALOR DEL CONTADOR PARA NO AFECTARLO EN EL PROCESO DE DETECCIÓN DE CARRY
	ANDI R16, 0b1111_0000			// ENMASCARO PARA SABER SI HUBO CARRY, SI EL RESULTADO DE ANDI ES DIFERENTE DE 0, HUBO CARRY 
	CPI R16, 0b0000_0000			// COMPARO EL RESULTADO DE LA MÁSCARA CON 0 
	BRNE LEDCARRY					// SALTA A LA SUBRUTINA LEDCARRY SI NO SON IGUALES 
	MOV R16, R22					// MOVER EL VALOR DEL RESULTADO A OTRO REGISTRO PARA NO AFECTARLO Y PODER SACAR EL VALOR EN EL PUERTO
	ORI R16, 0b1110_0000			// ORI PARA NO DESTRUIR PULL-UPS DEL PUERTOD 
	OUT PORTD, R16 
	RET 

LEDCARRY:
	LDI R16, 0b1111_0000
	OUT PORTD, R16 
	RET 

DELAY: 
	LDI R20, 0 
	LDI R21, 0 
BUCLE1: 
	INC R20
	CPI R20, 0
	BRNE BUCLE1 
	INC R21
	CPI R21, 0 
	BRNE BUCLE1
	RET

/******/
// Interrupt routines

/******/