/*
* NombreProgra.asm
*
* Creado: 12/02/2026
* Autor : Omar Cabrera 
* Descripción: Postlaboratorio #2 Control de encendido y apagado de un LED 
*/
/**/
// Encabezado (Definición de Registros, Variables y Constantes)
.include "M328PDEF.inc"     // Include definitions specific to ATMega328P
.dseg
.org    SRAM_START
//variable_name:     .byte   1   // Memory alocation for variable_name:     .byte   (byte size)

.cseg
.org 0x0000
 /**/
// CONFIGURACIÓN DE LA PILA
LDI     R16, LOW(RAMEND)
OUT     SPL, R16
LDI     R16, HIGH(RAMEND)
OUT     SPH, R16

// TABLA QUE CONTIENE TODOS LOS DATOS A DESPLEGAR PARA EL DISPLAY 
tabla7: .DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xB8, 0x80, 0x98, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E 

/**/
// Configuracion MCU
SETUP:
	// SETTING PRESCALER A 1MHZ 
	LDI R16, (1<<CLKPCE)
	STS CLKPR, R16						
	LDI R16, 0b0000_0100
	STS CLKPR, R16

	// CONFIGURACIÓN DEL TIMER0
	LDI R16, 0x0
	OUT TCCR0A, R16						// CONFIGURAR EL MODO DEL RELOJ, EN ESTE CASO MODO NORMAL 
	LDI R16, 0b0000_0101				
	OUT TCCR0B, R16						// CONFIGURAR EL PRESCALER A 1024 
	LDI R16, 0x9E						
	OUT TCNT0, R16						// CARGAR EL VALOR INICIAL DEL CONTADOR, EL VALOR CALCULADO FUE DE 158 


	// CONFIGURACIÓN DE SALIDAS PARA LOS LEDS EN EL PUERTO D, INICIALMENTE APAGADOS
	LDI R16, 0b1111_1111
	OUT DDRD, R16 
	LDI R16, 0b0000_0000 
	OUT PORTD, R16

	// DESACTIVAR UART (PARA QUE NO HAYAN PROBLEMAS CON TX y RX)
	LDI R16, 0x00
	STS UCSR0B, R16

	// PUNTERO Z PARA ESTABLECER EL HIGH Y LOW DE NUESTRO "DICCIONARIO"
	LDI ZH, HIGH(tabla7<<1)
	LDI ZL, LOW(tabla7<<1)
	LPM R17, Z							// CARGA EL VALOR DE Z EN R17 
	OUT PORTD, R17

	// CONFIGURACIÓN DE ENTRADAS PARA BOTONES Y SALIDA DE LA LED ALARMA  
	LDI R16, 0b0000_0100				// ENTRADA PARA LOS BOTONES EN PC0 Y PC1, ADEMÁS DE SALIDA PARA EL LED ALARMA
	OUT DDRC, R16 
	LDI R16, 0b0000_0011				// ACTIVA PULL-UP PARA LOS DOS BOTONES
	OUT PORTC, R16 
										// PC0 INCREMENTO 
										// PC1 DECREMENTO
										// PC2 LED DE ALARMA  


	// INICIALIZACIÓN DE VARIABLES 
	CLR R17								// VARIABLE DE TRABAJO
	CLR R20								// REGISTRO PARA DELAY
	CLR R21								// REGISTRO PARA DELAY 
	CLR R22								// CONTADOR HEXADECIMAL	
	CLR R23								// CONTADOR DE SEGUNDOS 
	CLR R24								// CONTADOR INTERMEDIO DE OVERFLOWS DEL TIMER0					
    
/**/
// Loop Infinito
LOOP:
	
	// LÓGICA DE BOTONES
	SBIS PINC, PC0						// REVISA EL PCO, SI ESTÁ PRESIONADO ES 0 Y LLAMA A LA FUNCIÓN 
	RCALL BOTON_INCREMENTAR	
	SBIS PINC, PC1						// REVISA EL PC1, BOTÓN PARA DECREMENTO
	RCALL BOTON_DECREMENTAR
	

	// LÓGICA DE TIMER
	IN R16, TIFR0						// ALMACENA LAS BANDERAS DEL TIMER 
	SBRS R16, TOV0						// LEE EL PIN 0 DE TIFR0, QUÉ ES TOV0, SI ESTÁ EN 1 (PORQUE HUBO OVERFLOW, SKIPEA INSTRUCCIÓN)
	RJMP LOOP 
	SBI TIFR0, TOV0						// PONE EN 1 LA BANDERA TOV0 PARA LIMPIAR EL OVERFLOW
	LDI R16, 0x9E
	OUT TCNT0, R16						// VUELVE A COLOCAR VALOR INICIAL AL TIMER
	INC R24								// REGISTRO PARA LLEVAR LA CUENTA DE LOS 10 DESBORDAMIENTOS 
	CPI R24, 0xA						// COMPARA EL REGISTRO CON 10
	BRNE LOOP							// CUANDO EL CONTADOR HAYA LLEGADO A 10, ENTONCES PROCEDE A AUMENTAR EL CONTADOR DE SEGUNDOS
	CLR R24								// LIMPIAR CONTADOR DE OVERFLOWS CUANDO LLEGUE A 10 
	INC R23								// SUMAR CONTADOR DE SEGUNDOS 
	CPI R23, 0x10						// COMPARAR VALOR DEL CONTADOR DE SEGUNDOS CON 16 					
	BREQ OVERFLOW_CONTADOR				// SE COMPARA EL CONTADOR CON 16, DE SER IGUALES SALTA A OVERFLOW_CONTADOR
	OUT PORTB, R23						// MOSTRAR CONTADOR DE SEGUNDOS POR MEDIO DE LOS LEDS 


	//LÓGICA PARA COMPARAR CONTADOR DE SEGUNDOS CON EL HEXADECIMAL 

	CP R23, R22							// COMPARA CONTADOR DE LEDS CON EL HEXADECIMAL 
	BREQ LED_LLAMADA
    RJMP LOOP
	
	
	
	


/**/
// NON-Interrupt subroutines

LED_LLAMADA:
	RCALL LED_ALARMA
	RJMP LOOP 

LED_ALARMA: 
	CLR R23								// REINICIAR CONTADOR DE SEGUNDOS. 
	IN R16, PORTC						// TRABAJAR EN OTRO REGISTRO LAS SALIDAS DE PORTC
	CPI R16, 0x03						// COMPARAR CON 0x03 (LED APAGADO) 
	BREQ LED_ENCENDER					// DE SER IGUALES, SIGNIFICA QUE EL LED ESTABA APAGADO Y LLAMAMOS A LA FUNCIÓN DE ENCENDER 
	CPI R16, 0x07						// COMPARAR CON 0x07 (LED ENCENDIDO)
	BREQ LED_APAGAR						// SI SON IGUALES, EL LED ESTABA ENCENDIDO Y LLAMAMOS A LA FUNCIÓN APAGAR
	RET						

LED_ENCENDER:
	LDI R17, 0b00000111
	OUT PORTC, R17 
	RET	

LED_APAGAR:
	LDI R17, 0b00000011
	OUT PORTC, R17 
	RET	



OVERFLOW_CONTADOR:						// SE REINICIA EL CONTADOR DE SEGUNDOS
	LDI R23, 0x0 
	OUT PORTB, R23
	RJMP LOOP 

BOTON_INCREMENTAR:						// RUTINA PARA ANTIRREBOTE 
	CALL DELAY 
	SBIC PINC, PC0						// LECTURA DEL PIN PARA DETECTAR SI EL BOTONAZO FUE REAL 
	RET									// SI EL BOTONAZO FUE FALSO, REGRESA A LA RUTINA NORMAL 
	RCALL INCREMENTAR_CONTADOR			// DE SER UN BOTONOZA REAL, SE LLAMA A LA RUTINA PARA INCREMENTAR EL CONTADOR 
VERIFICAR_PULSACION_INCREMENTO:
	SBIS PINC, PC0						// PARA EVITAR SEGUIR INCREMENTANDO,  SI EL BOTÓN SIGUE PRESIONADO, SE MANTIENE ES ESTA RUTINA HASTA QUE SE SUELTE (SUELTO=1)
	RJMP VERIFICAR_PULSACION_INCREMENTO
	RET

BOTON_DECREMENTAR:						// MISMA LÓGICA DE ANTIRREBOTE QUE EL BOTÓN DE INCREMENTO 
	CALL DELAY 
	SBIC PINC, PC1 
	RET
	RCALL DECREMENTAR_CONTADOR
VERIFICAR_PULSACION_DECREMENTO:
	SBIS PINC, PC1 
	RJMP VERIFICAR_PULSACION_DECREMENTO
	RET


INCREMENTAR_CONTADOR:
	INC R22								// INCREMENTAR CONTADOR
	CPI R22, 0x10						// SI EL CONTADOR ES DIFERENTE DE DE 16, AUN NO HAY OVERFLOW, SALTA A LA SUBRUTINA MUESTRA_CONTADOR
	BRNE MUESTRA_CONTADOR
	CLR R22								// DE LLEGAR EL CONTADOR A 16, SE REINICIA
	LDI ZH, HIGH(tabla7<<1)				// REINICIAMOS POSICIÓN DEL PUNTERO 
	LDI ZL, LOW(tabla7<<1)
	ADD ZL, R22							// LE SUMAMOS AL BYTE BAJO EL CONTADOR 
	ADC ZH, R1							// R1 SIEMPRE TIENE CERO, PERO SI LA SUMA ANTERIOR TIENE CARRY, AL BYTE ALTO DE Z, ZH, SE LE SUMA ESE CARRY 
	LPM R16, Z							// SE CARGA EL VALOR DE LA NUEVA POSICIÓN DE Z
	OUT PORTD, R16						// SE SACA LA POSICIÓN DE Z CALCULADA 
	RET

DECREMENTAR_CONTADOR:  
	DEC R22
	CPI R22, 0xFF						// SI HAY DECREMENTO, DE 0 PASA A 255 
	BRNE MUESTRA_CONTADOR				// SI EL CONTADOR ES DIFERENTE DE 255, SALTA A LA SUBRUTINA MUESTRA_CONTADOR
	LDI R22, 0xF						// SI EL CONTADOR SI ES 255, LO REESTABLECEMOS A 15
	LDI ZH, HIGH(tabla7<<1)				// REINICIAMOS POSICIÓN DEL PUNTERO 
	LDI ZL, LOW(tabla7<<1)
	ADD ZL, R22							// LE SUMAMOS AL BYTE BAJO EL CONTADOR 
	ADC ZH, R1							// R1 SIEMPRE TIENE CERO, PERO SI LA SUMA ANTERIOR TIENE CARRY, AL BYTE ALTO DE Z, ZH, SE LE SUMA ESE CARRY 
	LPM R16, Z							// SE CARGA EL VALOR DE LA NUEVA POSICIÓN DE Z
	OUT PORTD, R16						// SE SACA LA POSICIÓN DE Z CALCULADA 
	RET

MUESTRA_CONTADOR: 
	LDI ZH, HIGH(tabla7<<1)				// REINICIAMOS POSICIÓN DEL PUNTERO 
	LDI ZL, LOW(tabla7<<1)
	ADD ZL, R22							// LE SUMAMOS AL BYTE BAJO EL CONTADOR 
	ADC ZH, R1							// R1 SIEMPRE TIENE CERO, PERO SI LA SUMA ANTERIOR TIENE CARRY, AL BYTE ALTO DE Z, ZH, SE LE SUMA ESE CARRY 
	LPM R16, Z							// SE CARGA EL VALOR DE LA NUEVA POSICIÓN DE Z
	OUT PORTD, R16						// SE SACA LA POSICIÓN DE Z CALCULADA 
	RET 
	
DELAY: 
	LDI R20, 0  
BUCLE1: 
	INC R20
	CPI R20, 0
	BRNE BUCLE1 
	RET

/**/
// Interrupt routines

/**/